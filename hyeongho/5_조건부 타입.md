# 조건부 타입

- 중복되는 타입 코드를 제거하고 상황에 따라 적절한 타입을 얻을 수 있기에 정확한 타입 추론이 가능하다.

## extends와 제네릭을 이용한 조건부 타입

- 조건부 타입에서 extends를 사용할 때는 JS 삼항연산자와 함께 사용한다.
  `T extends U ? X : Y` => 타입 T를 U에 할당할 수 있으면 X타입, 아니라면 Y타입으로 결정됨을 의미한다.

```ts
interface Bank {
  financialCode: string;
  companyName: string;
  name: string;
  fullName: string;
}

interface Card {
  financialCode: string;
  companyName: string;
  name: string;
  appCardType?: string;
}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```

- Card와 Bank의 다른 점은 Card는 appCardType으로 카드사 앱을 사용하여 카드 정보를 등록할 수 있는지를 구분할 수 있다.
- payMethod 타입은 제네릭 타입으로 extends를 사용한 조건부 타입이다.
- 제네릭에 card가 들어오면 Card 타입, 그 외의 값이 들어오면 Account타입으로 결정한다.

## 조건부 타입을 사용하지 않았을 때의 문제점

```ts
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>;
export const useGetRegisteredList = (
  type: "card" | "appcard" | "bank"
): UseQueryResult<PayMethodType[]> => {
  const url = `baeminpay/condes/${type === "appcard" ? "card" : type}`;

  const fetcher = fetcherFactory<PayMethodType[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE"
        ) ?? [];
      return useablePocketList;
    },
  });

  const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);

  return result;
};
```

- useGetRegisteredList 함수는 타입으로 card, appcard, bank를 받아서 해당 결제 수단의 결제 수단 정보 리스트를 반환하는 함수이다.
- 이때, useGetRegisteredList함수가 반환하는 타입은 PocketInfo<Card> | PocketInfo<Bank>이다.
- 사용자가 타입으로 card를 넣었을 때 useGetRegisteredList함수가 반환하는 Data 타입은 PocketInfo라고 유추할 수 있다.

  - 하지만, useGetRegisteredList함수가 반환하는 Data 타입은 PayMethodType이기 때문에 사용하는 쪽에서 PocketInfo일 가능성도 있다.

- 즉, useGetRegisteredList함수는 타입을 구분해서 넣는 사용자의 의도와는 다르게 정확한 타입을 반환하지 못하는 함수가 됐다.
  - 인자에 따라 반환되는 타입을 다르게 설정하고 싶다면 extends를 사용한 조건부 타입을 활용하면 된다.

## extends 조건부 타입을 활용하여 개선하기

- 조건부 타입을 사용해서 PayMethodInfo<Card> | PayMethodInfo<Bank> 타입이였던 PayMethodType을 개선한다.

```tsx
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends
  | "card"
  | "appcard"
  ? Card
  : Bank;
```

- payMethodType의 제네릭으로 받은 값이 card 또는 appcard일 때는 card를, 아닐 때는 bank를 반환한다.
- 결제 수단 타입에서 card, appcard, bank만 들어올 수 있기 때문에 extends를 한정자로 활용하여 제네릭에 넘겨오는 값을 제한했다.

- 새롭게 정의한 PayMethodType에 제네릭 값을 넣어주기 위해 useGetRegisteredList 함수 인자의 타입을 넣어줘야 한다.
  - useGetRegisteredList인자 타입을 제네릭으로 받음녀서 extends를 활용하여 card, appcard, bank이외에 다른 값이 인자로 들어올 경우 타입 에러를 반환하도록 구현한다.

```tsx
export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
  type: T
): UseQueryResult<PayMethodType<T>[]> => {
  const url = `baeminpay/codes/${type === "appcard" ? "card" : type}`;

  const fetcher = fetcherFactory<PayMethodType<T>[]>({
    onSuccess: (res) => {
      const usablePocketList =
        res?.filter(
          (pocket: PocketInfo<Card> | PocketInfo<Bank>) =>
            pocket?.useType === "USE"
        ) ?? [];
      return usablePocketListl;
    },
  });

  const result = useCommonQuery<PayMethodType<T>[]>(url, undefined, fetcher);

  return result;
};
```

- 조건부 타입을 활용하여 PayMethodType이 사용자가 인자에 넣는 타입 값에 맞는 타입만을 반환하도록 구현했다.
  - 인자로 card, appcard를 넣는다면 Card를 반환하고, bank를 넣는다면 Bank를 반환한다.
    - 사용자는 타입 가드를 사용하지 않아도 된다.
    - 사용자는 card만을 받는 컴포넌트의 props로 넘겨줄 때 타입 단언을 사용하지 않아도 된다.

### extends 활용 예시 정리

1. 제네릭과 extends를 함께 사용하여 제네릭으로 받는 타입을 제한했다. => 휴면 에러 방지 가능
2. extends를 활용하여 조건부 타입을 설정했다. 조건부 타입을 사용하여 반환 값을 사용자가 원하는 값으로 구체화할 수 있다. => 불필요한 타입 가드, 타입 단언 등 방지가 가능하다.

## infer를 활용하여 타입 추론하기

- 삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고 infer로 타입을 추론하는 방식을 취한다.

```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

- 제네릭으로 T를 받아 T가 promise로 래핑된 경우라면 K를 반환하고, 그렇지 않은 경우에는 any를 반환한다.
- Promise<infer k>는 Promise의 반환 값을 추론하여 해당 값의 타입을 K로 한다는 의미이다.

```tsx
interface RouteBase {
  name: string;
  path: string;
  component: ComponentType;
}

export interface RouteItem {
  name: string;
  path: string;
  component?: ComponentType;
  pages?: RouteBase[];
}

export const routes: RouteItem[] = [
  {
    name: "기간 내역 관리",
    path: "/device-history",
    component: DeviceHistoryPage,
  },
  {
    name: "헬멧 인증 관리",
    path: "helmet-certification",
    component: HelmetCertificationPage,
  },
];
```

- RouteBase와 RouteItem은 라이더 어드민에서 라우팅을 위해 사용하는 타입이다.
- 권한 API로 반환된 사용자 권한과 name을 비교하여 인가되지 않은 사용자의 접근을 방지한다.

```tsx
export interface SubMenu {
  name: string;
  path: string;
}

export interface MainMenu {
  name: string;
  path?: string;
}
```
